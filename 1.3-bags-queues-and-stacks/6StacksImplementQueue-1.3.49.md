#### 要求

使用常数个栈实现先入先出的入队、出队，最坏时间复杂度为常数。

#### 0. 可视化表示

用字母表示栈名，栈纵向放置时开口朝上，用下划线表示栈底；横向放置用方括号表示栈底和开口。尽量用H(ead)和T(ail)表示队列API的队首队尾，队列左进右出。

```
8 7 6 5
-----T]
```

表示一个有4个元素的栈T向左开口画出

```
| 1
| 2
| 3
S 4
_ 5

```

表示一个有5个元素的栈S向上开口画出

#### 1. 朴素做法

```
T][H
```

队列入队：`T.push(v)`

队列出队：
```python
while T: H.push(T.pop())
ret = H.pop()
while H: T.push(H.pop())
```

出队操作耗时与元素个数线性相关

#### 2. 避免H栈中的元素回到T栈

如果可以把元素保留在H栈中，似乎会使算法朝着目标前进。

考虑如下场景，H、T栈中已经有部分元素，如何使T栈中的元素放置进H栈的合法位置？

```
8 7 6 5 3 2 1    -->      8 7 6 5 3 2 1
-----T] [H---           T][H-----------
```

引入辅助栈H'、HR。H'的作用是翻转T中元素顺序，保证队列API的先进先出。

```
8 7 6 5 --> 8 7 6 5
-----T]     [H'----
```

在翻转完成后，如果可以把H'拼接到H尾部（或者H拼接到H'头部），就可以达成“使T栈中的元素放置进H栈的合法位置”的目标。

栈并不是队列，无法直接完成拼接，需要一个栈“暂存”一下，这就是HR的作用。在“暂存”结束后，需要用H'即为新的H。

```
8 7 6 5         8 7 6 5              8 7 6 5 3 2 1
[H'----         [H'----              [H'----------

3 2 1             
[H---      -->  [H             -->   [H
                               
                         | 3     
       HR               HR 2                   HR
       __               __ 1                   __
```

上述流程可以分为3部分，1）T到H'，2）H到HR，3）HR到H'。其中3）依赖于1）和2），1）和2）不相互依赖。

将上述这个操作封装为一个方法，可以实现H栈中的元素不必退回到T栈中。该方法的一个可能的应用是：

```
      enqueue 123   3 2 1       run      3 2 1   enqueue 45   5 4 3 2 1     run      5 4 3 2 1
T][H    -->         ---T][H     -->    T][H---      -->       -T] [H---     -->    T][H------- 
```

可以看到，如果整个方法的运行是原子性的，不用考虑运行中需要响应队列入队出队，就可以实现本节“使T栈中的元素放置进H栈的合法位置”的目标，但是整个方法耗时仍然是线性。

#### 3. 均摊

上述方法耗时与队列元素个数呈线性关系，考虑到队列元素的增加（减少）一定对应着入队（出队）方法，如果可以将上面的方法均摊给每一次入队出队即可达到常数时间的要求。但是方法原子性的破坏引入了另外的问题：在方法运行中途，如果H、T中的元素因为入队出队发生变化要如何处理？

首先我们证明这一问题可以被解决。在方法运行中需要入队，只需要用一个新的栈T'代替T的作用，在方法完成后使用T'代替T。

在方法运行中需要出队，由于当时H、HR、H'的状态无法确定，而且出队耗时应当与元素数目无关，一个简单的方法是在H弹栈的时候仅移动栈顶指针，不真正从栈中删除元素，从而保证依然保存需要输出的元素顺序用于出队。但是这要使用比栈API更底层的指针实现，不满足题目要求。

更优雅的方法是同时维护两个栈H和h，该方法操作H栈，出队时操作h栈。对于h栈的操作如何同步到方法运行结束后的H栈上呢？h栈出队的元素一定在HR底部，只需要记录出队个数并标记这些元素不需要再被放回H'栈即可。

由上可知，均摊操作不会破坏前一节的性质，接下来我们研究如何实现。

上述方法定义较为优良，与外部操作的几乎没有关系，唯一的外部影响是出队时需要标记HR中相应数目的元素，这可能会有爆栈的隐患。接下来的分析使用入栈出栈作为成本模型。由上一节的讨论，该方法的1）和2）可以并行运行，运行的入栈操作数目等于出栈操作数目，等于H或T元素个数的较大者。3）的入栈操作数目等于出栈操作数目，小于等于HR的元素个数，而HR的元素个数等于H元素个数，因此该方法共计`max(#T, #H) + #HR <= max(#T, #H) + #H`次入栈和出栈。

为了使HR不爆栈，最严格的情况是需要在`#H`次出队操作前完成该方法（因为入栈操作也被均摊，会加速该方法的运行），如果限制`#T`与`#H`的关系，例如`#T = #H`，则可以有上一段的不等式估计1次出队操作需要运行2次或以上的方法子操作。以1次出队操作运行3次方法子操作为例，不妨假设此时H中有3n个元素，T有3n个元素。在2n次出队以后，该方法运行了6n次子步骤，达到了上界`max(3n, 3n) + 3n`，方法已经结束。因此我们可以控制方法的开始时机（`#T = #H`）以及一次入队（出队）运行几个方法子步骤避免HR爆栈。

更精细的不等式条件推导可以查看原始论文2.3.2、2.3.3节，我们可以在`#T = #H + 1`并1次入队（出队）运行2次方法子操作达到要求。

#### 4. 实现

Lisp实现参考原始论文。Python实现等待更新

#### ref

https://ecommons.cornell.edu/bitstream/handle/1813/6273/80-433.pdf
