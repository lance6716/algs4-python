#### 要求

使用常数个栈实现先入先出的入队、出队，最坏时间复杂度为常数。

#### 0. 可视化表示

用字母表示栈名，栈纵向放置时开口朝上，用下划线表示栈底；横向放置用方括号表示栈底和开口。尽量用H(ead)和T(ail)表示队列API的队首队尾，队列左进右出。

```
8 7 6 5
-----T]
```

表示一个有4个元素的栈T向左开口画出

```
| 1
| 2
| 3
S 4
_ 5

```

表示一个有5个元素的栈S向上开口画出

#### 1. 朴素做法

```
3 2 1
---T][H
```

队列入队：`T.push(v)`

队列出队：
```python
while T: H.push(T.pop())
ret = H.pop()
while H: T.push(H.pop())
return ret
```

出队操作耗时与元素个数线性相关

#### 2. 避免H栈中的元素回到T栈

上一节耗时的主要原因是元素在H栈和T栈中反复复制，如果可以把元素保留在H栈中，似乎会使算法朝着目标前进。

考虑如下场景，H、T栈中已经有部分元素，如何使T栈中的元素放置进H栈的合法位置？

```
8 7 6 5 3 2 1    -->      8 7 6 5 3 2 1
-----T] [H---           T][H-----------
```

引入辅助栈H'、HR。H'的作用是翻转T中元素顺序，保证队列API的先进先出。

```
8 7 6 5 --> 8 7 6 5
-----T]     [H'----
```

在翻转完成后，如果可以把H'拼接到H尾部（或者H拼接到H'头部），就可以达成“使T栈中的元素放置进H栈的合法位置”的目标。使用HR暂存H中的元素并弹回H'顶部，具体操作如下

```
8 7 6 5         8 7 6 5              8 7 6 5 3 2 1
[H'----         [H'----              [H'----------

3 2 1             
[H---      -->  [H             -->   [H
                               
                         | 3     
       HR               HR 2                   HR
       __               __ 1                   __
```

上述流程可以分为3部分，1）T到H'，2）H到HR，3）HR到H'。其中3）依赖于1）和2），1）和2）不相互依赖。

将上述这个操作封装为一个方法，可以实现H栈中的元素不退回到T栈中。该方法的一个可能应用是：

```
      enqueue 123   3 2 1       run      3 2 1   enqueue 45   5 4 3 2 1     run      5 4 3 2 1
T][H    -->         ---T][H     -->    T][H---      -->       -T] [H---     -->    T][H------- 
```

可以看到，如果该方法的运行是原子性的，不用考虑运行中需要响应队列入队出队，就可以实现本节“使T栈中的元素放置进H栈的合法位置”的目标，但是整个方法耗时仍然是线性。

#### 3. 均摊

上述方法耗时与队列元素个数呈线性关系。考虑到队列元素的增加（减少）一定对应着入队（出队）方法，如果可以将上面的方法均摊在入队出队时运行，即可避免线性耗时。但是方法原子性的破坏引入了另外的问题：在方法运行中途，如果H、T中的元素因为入队出队发生变化，又要如何处理。

首先我们证明这一问题可以被解决。在方法运行中需要入队，只需要用一个新的栈T'代替T的作用，在方法完成后使用T'代替T。

在方法运行中需要出队，队首元素可能位于H、HR中，状态无法确定，使用现有的栈无法完成这个操作，因此需要进一步增加栈保留H的原始信息。一个方法是在进入方法时创建一个H的副本以供出队调用；另一个方法是时刻维护一个H副本，在进入方法时脱离与H的同步并维护新的H副本，在结束方法时使用新副本取代旧副本。在题目要求中应尽量使用栈的公共API进行操作，而不是复制栈结构体的缓冲区指针（指向同一块区域的两个指针可能带来悬垂指针的风险），因此我们使用第二种方法实现。与H栈保持同步的副本是h，方法过程中创建的新副本是h'。

对于h栈的出队操作如何同步到方法运行结束后的H栈上呢？h栈出队的元素一定在HR底部，只需要记录出队个数`#deleted`并标记这些元素不需要再被放回H'栈即可。

由上可知，均摊操作不会破坏前一节的性质，接下来我们研究如何实现。

在上一节的分析中，该方法是T、H'、HR的纯函数。引入h、h'栈后出队元素个数会影响HR，需要保证HR中元素个数大于等于已出队元素个数`#deleted`，因此要重新考虑方法的边界条件。在方法的最后一部分3）时，达到`#HR = #deleted`时就需要退出，需要保证进入3）前有`#HR >= #deleted`。

Python实现中使用如下的策略：

1 若T非空：运行1）部分

2 若H非空：运行2）部分，此部分HR元素个数+1

3 若T空且H空：运行3）部分

需要注意在1）和2）都完成的那次函数调用中，会执行一次3）分支。我们把该方法的调用放在出队（入队）操作前，可以看到在最严格的连续出队时第1次出队前，`#HR = 1`……第`n`次出队前，`#HR = n`，当进入3）时该方法可以立即合法结束。当出队中有入队操作时，`#HR > n`，仍然满足要求。

#### 4. 实现

Lisp实现参考原始论文。Python实现 [7StacksImplementQueue-1.3.49.py](7StacksImplementQueue-1.3.49.py)

#### ref

https://ecommons.cornell.edu/bitstream/handle/1813/6273/80-433.pdf
